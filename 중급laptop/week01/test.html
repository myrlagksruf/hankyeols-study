<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body{
            margin:0;
            overflow: hidden;
        }
        canvas{
            width: 100vmin;
            height: 100vmin;
            margin: auto;
            display: block;
        }
        div{
            position: fixed;
            left:10px;
            top:10px;
            opacity: 0.2;
            transition: all 0.5s;
        }
        div:focus-within, div:hover{
            opacity: 1;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="800"></canvas>
    <div>
        너비 : <input min="2" step="1" type="number"><br>
        <button>이미지 받아오기</button>
        <button id="solve">풀기</button>
    </div>
    <script>
        const canvas = document.querySelector('canvas');
        const ctx = canvas.getContext('2d');
        const button = document.querySelector('button');
        const but2 = document.querySelector('#solve');
        const inp = document.querySelector('input');
        const way = [[-1, 0], [1, 0], [0, -1], [0, 1]];

        const around = (index) => {
            const x = index % len;
            const y = Math.floor(index / len);
            const result = [];
            if(index < 0 || index >= len * len) return [];
            for(let i of way){
                const X = x + i[0];
                const Y = y + i[1];
                if(X >= 0 && X < len && Y >= 0 && Y < len) result.push(Y * len + X);
            }
            return result;
        };

        let arr = [];
        let len = -1;

        class Data{
            arr = [];
            constructor(){}
            push(data){
                const arr = this.arr;
                if(arr.length === 0){
                    arr.push(data);
                    return 0;
                } else {
                    const index = this.find(arr, 0, arr.length - 1, data.score);

                    console.log(index);
                    this.arr.splice(index, 0, data);
                }
            }
            pop(){
                return this.arr.shift();
            }
            find(arr, left=0, right=-1, score){
                console.log(arr[left].score, arr[right].score);
                if(right === -1){
                    right = arr.length - 1;
                } else if(right - left <= 1){
                    if(arr[right].score <= score) return right + 1;
                    else if(arr[left].score <= score) return left + 1;
                    else return 0;
                }
                const mid = Math.floor((left + right) / 2);
                if(arr[mid].score <= score) left = mid;
                else right = mid;
                return this.find(arr, left, right, score);
            }
        }

        class His{
            history = {};
            constructor(){}
            has(cur){
                if(history[cur.map(v => v.y * len + v.x).join(',')]){
                    return true;
                } else {
                    return false;
                }
            }
            set(cur){
                history[cur.map(v => v.y * len + v.x).join(',')] = true;
            }
        }


        button.addEventListener('click', e => {
            const input = document.createElement('input');
            input.type = 'file';
            input.addEventListener('change', e => {
                console.log(30);
                const file = input.files[0];
                const url = URL.createObjectURL(file);
                const img = new Image();
                img.src = url;
                img.onload = () => {
                    arr = [];
                    len = Number(inp.value);
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
                    for(let i = 0; i < len; i++){
                        for(let j = 0; j < len; j++){
                            arr.push({
                                image:ctx.getImageData(j * canvas.width / len, i * canvas.height / len, canvas.width / len, canvas.height / len),
                                y:i,
                                x:j
                            });
                        }
                    }
                    arr.pop();
                    arr.push({image:null, x : len - 1, y : len - 1});
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    let count = 10000;
                    let index = len * len - 1;
                    while(count--){
                        const result = around(index);
                        const choice = result[Math.floor(Math.random() * result.length)];
                        const temp = arr[index];
                        arr[index] = arr[choice];
                        arr[choice] = temp;
                        index = choice;
                    }
                    for(let i = 0; i < len; i++){
                        for(let j = 0; j < len; j++){
                            if(arr[i * len + j].image === null) continue;
                            ctx.putImageData(arr[i * len + j].image, j * canvas.width / len, i * canvas.height / len);
                        }
                    }
                    URL.revokeObjectURL(url);
                }
            }, {once: true});
            input.click();
        });

        const moveTile = (x, y, maxFrame = 30) => new Promise((res, rej) => {
            const moveTo = [];
            let X, Y;
            if(arr[y * len + x].image !== null){
                for(let i of way){
                    X = x + i[0];
                    Y = y + i[1];
                    if(typeof arr[Y * len + X] === 'undefined'){
                        continue;
                    } else if(arr[Y * len + X].image === null) {
                        moveTo.push([canvas.width * x / len , canvas.height * y / len]);
                        moveTo.push([canvas.width * X / len , canvas.height * Y / len]);
                        const temp = arr[Y * len + X];
                        arr[Y * len + X] = arr[y * len + x];
                        arr[y * len + x] = temp;
                        break;
                    }
                }
            }
            let frame = 0;
            if(moveTo.length === 0) {
                res(-1);
            } else {
                const move = () => {
                    frame++;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    for(let i = 0; i < len; i++){
                        for(let j = 0; j < len; j++){
                            if(arr[i * len + j].image === null) continue;
                            if(i === Y && j === X) continue;
                            ctx.putImageData(arr[i * len + j].image, j * canvas.width / len, i * canvas.height / len);
                        }
                    }
                    ctx.putImageData(arr[Y * len + X].image,
                        (moveTo[1][0] * frame + moveTo[0][0] * (maxFrame - frame)) / maxFrame,
                        (moveTo[1][1] * frame + moveTo[0][1] * (maxFrame - frame)) / maxFrame);
                    if(frame === maxFrame){
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        for(let i = 0; i < len; i++){
                            for(let j = 0; j < len; j++){
                                if(arr[i * len + j].image === null) continue;
                                ctx.putImageData(arr[i * len + j].image, j * canvas.width / len, i * canvas.height / len);
                            }
                        }
                        res(1);
                    } else {
                        requestAnimationFrame(move);
                    }
                };
                move();
            }
        });



        const AI = async () => {
            // push, shift
            const que = new Data();
            const map = arr.map(v => ({x:v.x, y:v.y}));

            const history = new His();

            const isEnd = (A) => A.every((v, i) => {
                const y = Math.floor(i / len);
                const x = i % len;
                return v.x === x && v.y === y;
            });

            const empty = (A) => A.findIndex(v => v.x === len - 1 && v.y === len - 1);

            

            const moveT = (A, index) => {
                const cur = [...A];
                const E = empty(cur);
                const temp = cur[E];
                cur[E] = cur[index];
                cur[index] = temp;
                return cur;
            };

            const putAll = (one) => {
                const E = empty(one.cur);
                const indexes = around(E);
                for(let i of indexes){
                    const cur = moveT(one.cur, i);
                    const score = 4 * cal(cur) + one.path + 1;
                    if(!history.has(cur)){
                        que.push({
                            cur, pre:one, path:one.path + 1, score, index:i
                        });
                    }
                }
            };

            const cal = (A) => A.reduce((acc, v, i) => {
                let Y = Math.abs(Math.floor(i / len) - v.y);
                let X = Math.abs(i % len - v.x);
                return acc + Y + X;
            }, 0);

            const one = {
                cur: map,
                pre: null,
                path: 0,
                score: cal(map),
                index: -1
            };

            history.set(one.cur);

            putAll(one);

            let cur = que.pop();

            while(true){
                if(!cur) return null;
                if(!history.has(cur.cur)){
                    history.set(cur.cur);
                    if(isEnd(cur.cur)){
                        break;
                    } else {
                        putAll(cur);
                    }
                }
                cur = que.pop();
            }

            console.log(que.arr);

            let i = cur;
            const result = [];
            while(true){
                if(i.index === -1) return result;
                result.unshift(i.index);
                i = i.pre;
            }
        };

        but2.addEventListener('click', async e => {
            const result = await AI();
            for(let i of result){
                await moveTile(i % len, Math.floor(i / len), 5);
            }
        })

        canvas.addEventListener("click", async e => {
            if(canvas.classList.contains('load')) return;
            canvas.classList.add('load');
            const { width, height } = getComputedStyle(canvas);
            const x = Math.floor(e.offsetX / parseInt(width) * len);
            const y = Math.floor(e.offsetY / parseInt(height) * len);
            console.log('애니메이션 작동 여부', await moveTile(x, y, 30));
            canvas.classList.remove('load');
        });
    </script>
</body>
</html>