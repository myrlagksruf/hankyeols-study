<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas width="800" height="900"></canvas>
    <script>
        let cx = document.querySelector("canvas").getContext("2d");
        let x = 400;
        let y = 100;
        const c = Math.cos(Math.PI / 3);
        const s = Math.sin(Math.PI / 3);
        const work = new Set();

        function drawTri(length, color='white', frame = 100, dot = 6, tr){
            const cx = 0;
            const cy = -length * s * 2 / 3;
            const len = length * s / 3;
            const line0 = [];
            const line1 = [];
            const line2 = [];
            const order = [
                {x: 0, y: 0},
                {x: length * c, y: -length * s},
                {x: -length * c, y: -length * s}
            ];

            for(let i = 0; i < dot * 3; i++){
                const x = cx + len * Math.sin(Math.PI / (dot * 3) * 2 * i);
                const y = cy + len * Math.cos(Math.PI / (dot * 3) * 2 * i);
                line0.push({x:cx, y:cy});
                line1.push({x, y});
                const { x: x1, y: y1 } = order[Math.floor(i / dot)];
                const { x: x2, y: y2 } = order[(Math.floor(i / dot) + 1) % 3];
                const r = i % dot;
                line2.push({x: (x1 * (dot - 1 - r) + x2 * r) / (dot - 1), y : (y1 * (dot - 1 - r) + y2 * r) / (dot - 1)});
            }
            
            return { line:[ line0, line1, line2], frame, cur: 0, color, tr};
        }

        const draw = () => new Promise((res, rej) => {
            const ani = () => {
                for(let i of work){
                    cx.save();
                    cx.beginPath();
                    cx.setTransform(i.tr);
                    const index = (i.line.length - 1) * i.cur / i.frame;

                    const before = Math.floor(index);
                    const after = Math.ceil(index);
                    let br = 1;
                    let ar = 0;
                    if(before !== after){
                        br = after - index;
                        ar = index - before;
                    }
                    cx.fillStyle = i.color;

                    const bline = i.line[before];
                    const aline = i.line[after];

                    cx.moveTo(bline[0].x * br + aline[0].x * ar, bline[0].y * br + aline[0].y * ar);
                    for(let j = 1; j < bline.length; j++){
                        cx.lineTo(bline[j].x * br + aline[j].x * ar, bline[j].y * br + aline[j].y * ar);
                    }
                    cx.closePath();
                    cx.fill();
                    i.cur++;
                    if(i.cur === i.frame) work.delete(i);
                    cx.restore();
                }
                if(work.size) requestAnimationFrame(ani);
                else {
                    res();
                }
            };
            ani();
        });

        async function start(length, n = 1, color='white') {
            cx.save();
            cx.beginPath();
            cx.fillStyle = 'black';
            cx.moveTo(0, 0);
            cx.lineTo(-length * c, length * s);
            cx.lineTo(length * c, length * s);
            cx.closePath();
            cx.fill();
            function branch(length, n){
                console.log(n);
                if(n === 0){
                    const obj = drawTri(length, color, 200, 8, cx.getTransform());
                    work.add(obj);
                    return;
                }
                cx.save();
                cx.scale(0.5, 0.5);
                cx.translate(2 * c * length, 0);
                branch(length, n - 1);
                cx.translate(-4 * c * length, 0);
                branch(length, n - 1);
                cx.translate(2 * c * length, -2 * s * length);
                branch(length, n - 1);
                cx.restore();
            }
            cx.scale(0.5, 0.5);
            cx.translate(0, s * length * 2);
            for(let i = 0; i < n; i++){
                branch(length, i);
                await draw();
            }
            cx.restore();
        }
        cx.translate(x, y);
        start(800, 6, 'red');
    </script>
</body>
</html>